# AAE_Notebook_028_PIDControl
Now that we've looked at PD Control, let's take things a step further to a full PID Controller implementation...

### PID Control

In the previous notebook [AAE_Notebook_027_FeedForward](https://github.com/FadedIllusions/AAE_Notebook_027_FeedForward), if you played around with the mass error variable any at all (with 1.0 being not any error), you noticed that, when we introduce a mass error, we created a systematic bias within the PD Controller.

![Systematic Bias](/images/systematic_bias.png)

To correct for systematic bias, we need a full PID (Proportional-Integral-Derivative) Controller. 

![PID Equation](/images/PID_Equation.png)

If you recalll from calculus, the integral computes the area under the curve -- that is, an accumulated error over time. By introducing and integral term into our control system, we can further adjust the system to account for the accumulation of error over time.

![Reparameterized PID Equation](/images/reparameterized_pid.png)

***   ***   ***   ***   ***   ***   ***   ***   ***

### PD Tuning Considerations

If you don't want to think about delta and time constant, you can refer to the table below, which shows what to expect when tuning a system directly tweaking the values of Kp, Kd, Ki.

![PID Tuning Considerations](/images/pid_considerations.png)

***   ***   ***   ***   ***   ***   ***   ***   ***

## PID Controller Recap

![Closed Loop Controller](/images/closed_loop.png)

As seen in previous notebooks, the input to our system is the thrust we can command to the propellers (generated by the propellers' speed) and the output is the altitude from the ground. Conversely, the input of th controller is the measured error and the output is the thrust that the controller signals to the vehicle. (With error being the difference between the actual altitude and the target altitude.)

### Proportional Component

![Starting State](/images/p_001.png)

When we begin from the ground and wish to command our vehicle to some target altitude, the error will be fairly substantial. To compensate for such an error, we will input a thrust (derived from the propellers' speed) to allow the vehicle to liftoff and reduce the error.

What happens when the vehicle reaches the target altitude and the error becomes 0?

![Target Altitude](/images/p_002.png)

Since not any more thrust is needed, as we've exactly reached the target altitude, the commanded thrust is zero and will cause the vehicle to fall. As the vehicle falls and the error increases, the process will loop continuously, causing a constant oscillation about the target altitude.

Let’s take a step further and add the goal of hovering the drone to the target location. Hovering implies a lift thrust equal to the weight of the drone.

Let’s see how the proportional controller influences the behavior of the drone. Let’s assume that the equilibrium (hovering state) is reached when the thrust is equal to 100N.

If we pick a proportional gain (Kp) equal to 1, then the commanded thrust would be equivalent to 100 (error = 100; Kp=1 => thrust = 100*1 = 100N) and the drone would continue to hover at ground level. If we increase Kp to 5, then the drone will hover at an altitude of 80m, since the drone will reach the commanded thrust when the error is equal to 20m.

![Hovering](/images/p_003.png)

The more that we increase Kp, the smaller the error will become. Unfortunately, however, the error will not ever converge to 0 -- this is known as steady-state error.

![Steady State Error](/images/steady_state_error.png)

The proportional controller uses only present information. We were comparing actual altitude with target altitude. But to help us get rid of this constant error introduced by the proportional gain, we can use an integrator path into our controller.

### Integral Component

![Integrator Implementation](/images/pi_control.png)

Our integral term (defined by our integral-gain Ki) looks at past information and, thus, accumulates the amount of error within the system over time. It's used to adjust our control system to counter or reduce such accumulation. The more time we spend below our altitude target, the more thrust will be applied.

Therefore, if the drone is flying below the target altitude, then the integral component will provide a thrust higher than 100N (the equilibrium thrust). To remove the excess of thrust, we will need to have a negative error so that the accumulated sum of error lowers, and the integral component sends a signal to slow down the thrust. But, to get a negative error, the drone has to overshoot the target, then undershoot a bit until it finally reaches the target altitude.

Although a controller with proportional and integral components can help us eventually reach the target altitude, this overshooting is not ideal, and should be minimized it as much as possible. We need a term that 'looks into the future' of our system and helps to prevent such an overshoot.

### Derivative Component

![Full PID Control](/images/pid_control.png)

The derivative term measures the rate of change of the error; therefore, it sees how fast the error is increasing/decreasing. If decreasing too quickly, the rate of change is negative and the output of our derivative term of the controller is a negative output and, thus, it lowers the thrust. Now, we're able to decrease the commanded thrust as we near the target altitude and help prevent from overshooting.

***   ***   ***   ***   ***   ***   ***   ***   ***

## Saturation And Integral Windup

While we have seen how the PID controller works so far, we had restricted our view to an ideal scenario: linear systems. Linear systems have virtually no limitations, and respond “linearly” (of course!) to any command. To understand what we mean by that, let’s recall what the output of the controller is. In the previous example, we were dealing with thrust, which was applied to the behavior of our drone. In a real-world scenario, instead, this thrust gets transmitted to the drone through actuators. These actuators are not linear systems; instead, they have physical limitations, and can’t entirely follow the commands given to them.

Saturation is one of these limitations. It limits the ability of the actuator to follow a given command. This limit affects the integral part of the PID controller.

![Saturation](/images/saturation.png)

Let’s use the same example previously. Our initial state will be the same: the drone is staying on the ground waiting to lift off and reach the target altitude. This time, though, the motor spinning the propellers will have a limitation to the thrust it can provide. Let’s say that the max thrust is 200N.

If our drone is strapped to the ground, then the integral component of the PID controller will evaluate the past error (which is 100 meters), and will signal an increase of thrust. As long as the drone stays on the ground (and we are forcing it to), this accumulated error keeps growing, and the integral part will signal the motor to keep increasing the thrust. At a certain point, we will reach an interesting situation, where the motor cannot provide the thrust requested by the controller, but the controller keeps sending a signal to increase thrust. As long as the drone stays on the ground, the accumulated error increases and the requested thrust does as well.

Let’s say, for example, that the requested thrust has reached the value of 1,000N, but the motor can only deliver 200N.

As soon as we release the drone, it will quickly rise as the motor is requesting the maximum thrust. It’s easy to see that the drone will rapidly overshoot the target.

At this point, the error will become negative, and the commanded output will decrease. Interestingly, though, the commanded output will start decreasing from where it was before leaving the ground, which was around 1,000N. The motor, on the other hand, will continue to produce 200N until the commanded output decreases below that value. Until that point, the drone has been rising with a 200N thrust!

The area between the commanded thrust and the engine limitation thrust is called “integral windup”.

![Integral Windup](/images/integral_windup.png)

We want to minimize this windup area, which means that we want to reduce the time it takes to reverse command when the error changes sign, to stop the integrator from increasing its output value. A way to do that is to use “clamping,” which essentially turns the integrator off when we don’t want it to integrate any longer.

### Resources:
![Wikipedia - Integral Windup](https://en.wikipedia.org/wiki/Integral_windup)
![20-Sim Simulator](http://www.20sim.com/webhelp/library_signal_control_pid_control_antiwindup.php)
